# Скенер за файлове
В това домашно трябва да напишете програма, която сканира всички файлове намиращи се под дадена директория и извежда размера на тези от тях, които отговарят на даден критерий.

Програмата ви трябва да получи от стандартния вход два параметъра -- име на директория и шаблон за името на  файловете, които да се включат в резултатите. След това програмата ви трябва да изведе всички файлове отговарящи на шаблона, в намаляващ ред, според техния размер. Пръв трябва да се изведе най-големият файл, след него -- следващият по размер и т.н. Ако два файла имат еднакъв размер, те трябва да се подредят по лексикографската наредба, по техния пълен път. Например файлът `C:\A\file.txt` е по-напред в наредбата от файл с пълен път `C:\B\aaa.txt`.

Най-простият шаблон, който можете да реализирате, е по разширението на файловете. В този случай потребителят въвежда дадено разширение, като например “docx” и след това програмата ви трябва да изведе информация само за файлове, които имат това разширение. Забележете, че ако разширението, което търсим е “docx”, в резултатите НЕ трябва да се включва например файл с име “aaa.abcdocx”, т.е. прилагането на шаблона не може да се направи само с проверка дали разширението е суфикс на името на файла, а трябва да се потърси и разделящата точка.

Търсенето трябва да става в дълбочина -- както в подадената директория, така и във всички нейни поддиректории, техните поддиректории и т.н. Тъй като броят на директориите на дадено ниво може да бъде голям, помислете кой алгоритъм за обхождане ще използвате и как ще го реализирате, за да сте сигурни, че няма да имате проблем с паметта. Например обхождането не трябва да предизвиква препълване на стека, дори и при голям брой директории.

За улеснение може да считате, че в директорията, която ще бъде подадена на вашата програма, няма да се съдържат soft links, hard links или junctions (NTFS). Тоест ще работите с истинско дърво, а не с граф; може да считате, че в него нито може да има цикли, нито даден елемент може да се повтаря по няколко пъти. Също така, може да считате, че всички файлове ще са с размер по-малък от 232-1 (т.е. размерът се събира в 32-битова променлива без знак). Имената им ще съдържат само стандартни ASCII символи с кодове по-малки от 128 (няма нужда да използвате unicode). Дължината на името на всеки файл ще бъде по-малка от 260 символа (стойността на константата MAX_PATH във Windows).

За извличане на всички файлове и поддиректории в дадена директория можете да използвате например (в края на документа ще намерите допълнителна информация):
*   `Windows`: функциите **FindFirstFile**, **FindNextFile** и **FindClose**;
*   `Linux`:  функциите **opendir**, **readdir** и **closedir**;
*   `Платформено независимо`: **Boost Filesystem Library**.

Сами трябва да реализирате всички изисквания в задачата. Например сами трябва да напишете алгоритъм, който проверява дали даден символен низ (име на файл), отговаря на даден шаблон. За целта **НЕ МОЖЕ** да се използва готовата функционалност. Също така сами трябва да реализирате подходящо обхождане на дървото на директориите и подходяща сортировка. **НЕ МОЖЕ** да се използват готови функции за сортиране, като например std::sort.

При решаването на задачата може да се използват наготово функциите и класовете в STL, например std::string и базовите колекции std::vector, std::list std::forward_list, std::stack и std::queue. За всички структури от данни и алгоритми, които използвате наготово, трябва да разбирате как работят те и да можете да ги реализирате сами. Например ако използвате std::vector се предполага, че имате добро разбиране за структурата от данни динамичен масив и можете сами да напишете клас, който я реализира.

Обхождането на дървото трябва да стане чрез итератор. За целта създайте такъв, който обхожда всички директории под дадената и връща намиращите се в тях файлове. Създайте втори итератор, който разширява първия, като филтрира онези файлове, които не отговарят на шаблона. Използвайте итераторите, за да извлечете имената на файловете, които са ви нужни, за да решите задачата.

### Примери за обхождане на директории (API)
#### Windows
По-долу можете да намерите няколко прости примера за обхождане на директория. Примерът е за “плоско” обхождане -- само за една директория. Помислете как да го адаптирате така, че да можете да обходите цялото дърво.

https://github.com/semerdzhiev/sdp-samples/blob/master/Other/DirScan.cpp
https://gist.github.com/poseidon4o/cc6e4789704d559911741aa4d8267762

За по-подробен пример и информация за функциите в API-то, вижте например:
https://msdn.microsoft.com/en-us/library/aa365200(VS.85).aspx
https://msdn.microsoft.com/en-us/library/windows/desktop/aa365740(v=vs.85).aspx
#### Linux
Кратък пример за използване на функциите:
https://www.gnu.org/software/libc/manual/html_node/Simple-Directory-Lister.html

#### За повече информация:
https://www.gnu.org/software/libc/manual/html_node/Opening-a-Directory.html
http://man7.org/linux/man-pages/man3/opendir.3.html
https://www.gnu.org/software/libc/manual/html_node/Reading_002fClosing-Directory.html
#### Boost
За повече информация за Filesystem Library:
http://www.boost.org/doc/libs/1_36_0/libs/filesystem/doc/index.htm